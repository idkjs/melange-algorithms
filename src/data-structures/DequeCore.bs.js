// Generated by Melange
'use strict';

var List = require("bs-platform/lib/js/list.js");
var Stdlib = require("bs-platform/lib/js/stdlib.js");
var Exceptions = require("../Exceptions.bs.js");

var empty = {
  front: /* [] */0,
  frontLen: 0,
  rear: /* [] */0,
  rearLen: 0
};

function make(param) {
  return empty;
}

function isEmpty(deque) {
  if (deque.frontLen === 0) {
    return deque.rearLen === 0;
  } else {
    return false;
  }
}

function length(deque) {
  return deque.frontLen + deque.rearLen | 0;
}

function maintain(deque) {
  var front = deque.front;
  var rearLen = deque.rearLen;
  var frontLen = deque.frontLen;
  if (frontLen > ((rearLen << 1) + 1 | 0)) {
    var i = (frontLen + rearLen | 0) / 2 | 0;
    var j = (frontLen + rearLen | 0) - i | 0;
    var match = List.fold_left((function (param, el) {
            var rest = param[2];
            var newFront = param[1];
            var ct = param[0];
            if (ct < i) {
              return [
                      ct + 1 | 0,
                      {
                        hd: el,
                        tl: newFront
                      },
                      rest
                    ];
            } else {
              return [
                      ct + 1 | 0,
                      newFront,
                      {
                        hd: el,
                        tl: rest
                      }
                    ];
            }
          }), [
          0,
          /* [] */0,
          /* [] */0
        ], front);
    var newFront = List.rev(match[1]);
    var newRear = Stdlib.$at(deque.rear, match[2]);
    return {
            front: newFront,
            frontLen: i,
            rear: newRear,
            rearLen: j
          };
  }
  var rearLen$1 = deque.rearLen;
  var frontLen$1 = deque.frontLen;
  if (rearLen$1 <= ((frontLen$1 << 1) + 1 | 0)) {
    return deque;
  }
  var i$1 = (frontLen$1 + rearLen$1 | 0) / 2 | 0;
  var j$1 = (frontLen$1 + rearLen$1 | 0) - i$1 | 0;
  var match$1 = List.fold_left((function (param, el) {
          var rest = param[2];
          var newRear = param[1];
          var ct = param[0];
          if (ct < j$1) {
            return [
                    ct + 1 | 0,
                    {
                      hd: el,
                      tl: newRear
                    },
                    rest
                  ];
          } else {
            return [
                    ct + 1 | 0,
                    newRear,
                    {
                      hd: el,
                      tl: rest
                    }
                  ];
          }
        }), [
        0,
        /* [] */0,
        /* [] */0
      ], deque.rear);
  var newRear$1 = List.rev(match$1[1]);
  var newFront$1 = Stdlib.$at(front, match$1[2]);
  return {
          front: newFront$1,
          frontLen: i$1,
          rear: newRear$1,
          rearLen: j$1
        };
}

function addFirst(el, deque) {
  return maintain({
              front: {
                hd: el,
                tl: deque.front
              },
              frontLen: deque.frontLen + 1 | 0,
              rear: deque.rear,
              rearLen: deque.rearLen
            });
}

function getFirstExn(deque) {
  var match = deque.front;
  if (match) {
    return match.hd;
  }
  var match$1 = deque.rear;
  if (match$1) {
    if (match$1.tl) {
      throw {
            RE_EXN_ID: Exceptions.InternalError,
            _1: "DequeCore.getFirstExn",
            Error: new Error()
          };
    }
    return match$1.hd;
  }
  throw {
        RE_EXN_ID: Exceptions.Empty,
        _1: "DequeCore.getFirstExn",
        Error: new Error()
      };
}

function dropFirstExn(deque) {
  var match = deque.front;
  if (match) {
    return maintain({
                front: match.tl,
                frontLen: deque.frontLen - 1 | 0,
                rear: deque.rear,
                rearLen: deque.rearLen
              });
  }
  var match$1 = deque.rear;
  if (match$1) {
    if (match$1.tl) {
      throw {
            RE_EXN_ID: Exceptions.InternalError,
            _1: "DequeCore.dropFirstExn",
            Error: new Error()
          };
    }
    return empty;
  }
  throw {
        RE_EXN_ID: Exceptions.Empty,
        _1: "DequeCore.dropFirstExn",
        Error: new Error()
      };
}

function addLast(el, deque) {
  return maintain({
              front: deque.front,
              frontLen: deque.frontLen,
              rear: {
                hd: el,
                tl: deque.rear
              },
              rearLen: deque.rearLen + 1 | 0
            });
}

function getLastExn(deque) {
  var match = deque.front;
  if (match) {
    if (!match.tl) {
      if (deque.rear) {
        return deque.rear.hd;
      } else {
        return match.hd;
      }
    }
    if (deque.rear) {
      return deque.rear.hd;
    }
    throw {
          RE_EXN_ID: Exceptions.InternalError,
          _1: "DequeCore.getLastExn",
          Error: new Error()
        };
  }
  if (deque.rear) {
    return deque.rear.hd;
  }
  throw {
        RE_EXN_ID: Exceptions.Empty,
        _1: "DequeCore.getLastExn",
        Error: new Error()
      };
}

function removeLastExn(deque) {
  var match = deque.front;
  if (match) {
    if (match.tl) {
      if (!deque.rear) {
        throw {
              RE_EXN_ID: Exceptions.InternalError,
              _1: "DequeCore.removeLastExn",
              Error: new Error()
            };
      }
      
    } else if (!deque.rear) {
      return empty;
    }
    
  } else if (!deque.rear) {
    throw {
          RE_EXN_ID: Exceptions.Empty,
          _1: "DequeCore.removeLastExn",
          Error: new Error()
        };
  }
  return maintain({
              front: deque.front,
              frontLen: deque.frontLen,
              rear: deque.rear.tl,
              rearLen: deque.rearLen - 1 | 0
            });
}

function reverse(deque) {
  return {
          front: deque.rear,
          frontLen: deque.rearLen,
          rear: deque.front,
          rearLen: deque.frontLen
        };
}

function fromList(list) {
  return List.fold_left((function (acc, el) {
                return addLast(el, acc);
              }), empty, list);
}

function toList(deque) {
  return Stdlib.$at(deque.front, List.rev(deque.rear));
}

var c = 2;

exports.c = c;
exports.empty = empty;
exports.make = make;
exports.isEmpty = isEmpty;
exports.length = length;
exports.maintain = maintain;
exports.addFirst = addFirst;
exports.getFirstExn = getFirstExn;
exports.dropFirstExn = dropFirstExn;
exports.addLast = addLast;
exports.getLastExn = getLastExn;
exports.removeLastExn = removeLastExn;
exports.reverse = reverse;
exports.fromList = fromList;
exports.toList = toList;
/* No side effect */
