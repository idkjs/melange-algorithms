// Generated by Melange
'use strict';

var List = require("bs-platform/lib/js/list.js");
var $$Array = require("bs-platform/lib/js/array.js");
var Curry = require("bs-platform/lib/js/curry.js");
var Caml_obj = require("bs-platform/lib/js/caml_obj.js");
var Caml_array = require("bs-platform/lib/js/caml_array.js");
var Caml_int32 = require("bs-platform/lib/js/caml_int32.js");
var Caml_exceptions = require("bs-platform/lib/js/caml_exceptions.js");

function create(pre_hash, hash) {
  return {
          pre_hash: pre_hash,
          hash: hash,
          table: {
            contents: [/* [] */0]
          },
          num_bindings: {
            contents: 0
          },
          load: 16
        };
}

var Key_not_found = /* @__PURE__ */Caml_exceptions.create("HashtblWithChaining.Key_not_found");

function bucket(map, key) {
  var table = map.table.contents;
  var number_buckets = table.length;
  var bucket_index = Curry._2(map.hash, number_buckets, Curry._1(map.pre_hash, key));
  var bucket$1 = Caml_array.get(table, bucket_index);
  return [
          bucket$1,
          bucket_index
        ];
}

function remove_from_bucket(bucket, key) {
  var _prev = /* [] */0;
  var _next = bucket;
  while(true) {
    var next = _next;
    var prev = _prev;
    if (next) {
      var e = next.hd;
      if (Caml_obj.caml_equal(e.key, key)) {
        return List.rev_append(prev, next.tl);
      }
      _next = next.tl;
      _prev = {
        hd: e,
        tl: prev
      };
      continue ;
    }
    throw {
          RE_EXN_ID: Key_not_found,
          Error: new Error()
        };
  };
}

function iter(f, map) {
  var f$1 = function (e) {
    return Curry._2(f, e.key, e.value);
  };
  var iter_bucket = function (bucket) {
    var bucket$1 = List.rev(bucket);
    return List.iter(f$1, bucket$1);
  };
  return $$Array.iter(iter_bucket, map.table.contents);
}

function expected_num_buckets(map) {
  var num_buckets = map.table.contents.length;
  var load = Caml_int32.div(map.num_bindings.contents, num_buckets);
  if (load > (map.load << 1)) {
    return (num_buckets << 1);
  } else if (load < (map.load / 2 | 0) && num_buckets > 1) {
    return num_buckets / 2 | 0;
  } else {
    return num_buckets;
  }
}

function maybe_rehash(map) {
  var num_buckets = map.table.contents.length;
  var expected_num_buckets$1 = expected_num_buckets(map);
  if (num_buckets !== expected_num_buckets$1) {
    var pre_hash = map.pre_hash;
    var hash = Curry._1(map.hash, expected_num_buckets$1);
    var table = Caml_array.make(expected_num_buckets$1, /* [] */0);
    var populate = function (key, value) {
      var bucket_index = Curry._1(hash, Curry._1(pre_hash, key));
      var bucket = Caml_array.get(table, bucket_index);
      return Caml_array.set(table, bucket_index, {
                  hd: {
                    key: key,
                    value: value
                  },
                  tl: bucket
                });
    };
    iter(populate, map);
    map.table.contents = table;
    return ;
  }
  
}

function find(map, key) {
  var match = bucket(map, key);
  return List.find((function (binding) {
                return Caml_obj.caml_equal(binding.key, key);
              }), match[0]).value;
}

function add(map, key, value) {
  var match = bucket(map, key);
  Caml_array.set(map.table.contents, match[1], {
        hd: {
          key: key,
          value: value
        },
        tl: match[0]
      });
  map.num_bindings.contents = map.num_bindings.contents + 1 | 0;
  return maybe_rehash(map);
}

function remove(map, key) {
  var match = bucket(map, key);
  Caml_array.set(map.table.contents, match[1], remove_from_bucket(match[0], key));
  map.num_bindings.contents = map.num_bindings.contents - 1 | 0;
  return maybe_rehash(map);
}

function length(map) {
  return map.num_bindings.contents;
}

exports.create = create;
exports.Key_not_found = Key_not_found;
exports.find = find;
exports.add = add;
exports.remove = remove;
exports.iter = iter;
exports.length = length;
/* No side effect */
